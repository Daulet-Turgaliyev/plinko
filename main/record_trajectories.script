local trajectories = {}
local last_position = nil
local last_contact_time = nil
local recording = true
local record_count = 5

local function sanitize_filename(str)
	local hashToString = str:gsub("[^%w]", "_")
	local cleaned_string = string.gsub(hashToString, "hash____", "")
	cleaned_string = string.gsub(cleaned_string, "_", "")
	return cleaned_string
end

local function record_position(self)
		--[[if recording then
		local pos = go.get_position(self.ball)
		local current_time = socket.gettime()
		local time_delta = 0
		if last_contact_time then
			time_delta = current_time - last_contact_time
		end
		table.insert(trajectories, {position = pos, delta = time_delta})
		last_contact_time = current_time
		last_position = pos
	end]]
end


local function save_trajectories_to_file(trajectories, backetID)
	local sanitized_backetID = sanitize_filename(backetID)
	local file_path = "settings/physics_baked/" .. sanitized_backetID .. ".json"
	local existing_data = {}

	-- Check if the file exists and load its content
	local file = io.open(file_path, "r")
	if file then
		local content = file:read("*a")
		existing_data = json.decode(content) or {}
		file:close()
	end

	-- Initialize the backetID table if it does not exist
	if not existing_data[backetID] then
		existing_data[backetID] = {}
	end

	-- Find the next record index
	local next_index = 1
	for key, _ in pairs(existing_data[backetID]) do
		local index = tonumber(key:match("record(%d+)"))
		if index and index >= next_index then
			next_index = index + 1
		end
	end

	-- Add new trajectories under a unique record key if the limit is not reached
	if next_index <= record_count then
		local record_key = "record" .. next_index
		existing_data[backetID][record_key] = {}
		for _, entry in ipairs(trajectories) do
			table.insert(existing_data[backetID][record_key], {
				position = {
					x = entry.position.x,
					y = entry.position.y
				},
				delta = entry.delta
			})
		end
	else
		print("Maximum number of records reached for " .. backetID)
		return
	end

	local json_data = json.encode(existing_data)
	file = io.open(file_path, "w")
	if file then
		file:write(json_data)
		file:close()
	else
		print("Error: Unable to open file for writing:", file_path)
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.ball = go.get_id()

	record_position(self)

	-- Инициализация таймера
	self.timer_interval = 0.1 -- Интервал времени в секундах
	self.timer_id = nil -- Идентификатор таймера

	-- Запускаем таймер
	self.timer_id = timer.delay(self.timer_interval, true, function(self, handle, time_elapsed)
		on_timer_tick(self, handle, time_elapsed)
	end)

end

function on_timer_tick(self, handle, time_elapsed)
	record_position(self)
end

function final(self)
	-- Остановка таймера при завершении объекта
	if self.timer_id then
		timer.cancel(self.timer_id)
		self.timer_id = nil
	end
end

function update(self, dt)
	if recording then
		local pos = go.get_position(self.ball)
		if not last_position or pos.x ~= last_position.x or pos.y ~= last_position.y or pos.z ~= last_position.z then
			last_position = pos
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("save_record") and action.pressed then
		print("Number of elements in trajectories:", #trajectories)
		save_trajectories_to_file(trajectories, self.backetID)
		trajectories = {}  -- Сброс траекторий после сохранения
	end
end

function on_message(self, message_id, message, sender)
		--[[if message_id == hash("trigger_response") then
		recording = false
		local backetID = message.other_id
		self.backetID = tostring(backetID) 
		save_trajectories_to_file(trajectories, self.backetID)
		msg.post("/background#main", "respawn", nil)
		record_position(self)
		go.delete(self.ball)
	elseif message_id == hash("contact_point_response") then
		record_position(self)
	end]]
end
