
local function get_random_record(data)
	local records = {}
	
	for key, value in pairs(data) do
		
		for sub_key, sub_value in pairs(value) do
			if sub_key:match("record%d+") then
				table.insert(records, sub_value)
			end
		end
	end

	if #records > 0 then
		local random_index = math.random(1, #records)
		return records[random_index]
	else
		return nil
	end
end

local function load_trajectories(file_path)
	local existing_data = {}
	-- Check if the file exists and load its content
	local file = io.open(file_path, "r")
	if file then
		local content = file:read("*a")
		existing_data = json.decode(content) or {}
		file:close()
	else
		print("JSON файл не найден")
	end

	if not existing_data then
		existing_data = {}
		print("JSON сломан, не удалось извлечь данные")
	end

	local record = get_random_record(existing_data)

	local trajectories = {}


	for key, value in pairs(record) do
		local trajectory = {
			position = vmath.vector3(value.position.x, value.position.y, 0),
			delta = value.delta }
			table.insert(trajectories, trajectory)
		end

		return trajectories
end

local function animate_ball_to_basket(self, file_path)

	local trajectories = load_trajectories(file_path)

	local total_duration = 0
	for i = 2, #trajectories do
		local position = trajectories[i].position
		local delay = trajectories[i].delta
		total_duration = total_duration + delay
		go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, position, go.EASING_LINEAR, delay, total_duration - delay)
	end
end

function init(self)
	-- Инициализация случайного числа
	math.randomseed(os.time())
end

function on_message(self, message_id, message, sender)
	if message_id == hash("start_animation") then
		animate_ball_to_basket(self, message.records)
	elseif message_id == hash("trigger_response") then
		--sound.play("#sound")
	end
	
end
