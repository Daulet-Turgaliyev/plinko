local MAX_BALLS = 30
local RESTORE_AMOUNT = 5
local RESTORE_INTERVAL = 60 -- время в секундах
local SPAWN_INTERVAL = 0.2 -- интервал между спаунами

local balls = 0
local ball_pool = {}  -- Пул объектов
local active_balls = {}
local spawn_queue = {}
local is_spawning = false -- флаг для проверки активного спауна

local function save_data()
	local data = sys.load("save_data") or {}
	data.balls = balls
	sys.save("save_data", data)
end

local function load_data()
	local data = sys.load("save_data")
	if data then
		balls = data.balls or MAX_BALLS
	end

	msg.post("/background#mainScreen", "update_count_balls", { text = balls.."/"..MAX_BALLS })
end

function init(self)
	load_data()
	self.restore_timer = RESTORE_INTERVAL
	msg.post(".", "acquire_input_focus")
	math.randomseed(os.time())

	self.baskets = {}

	-- Инициализация пула объектов
	for i = 1, MAX_BALLS do
		local ball = factory.create("/localGeneratorfactory#ball_factory", vmath.vector3(320, 1000, 0))
		table.insert(ball_pool, ball)
		msg.post(ball, "disable")  -- Отключаем объект
	end
end

function on_input(self, action_id, action)
	if action_id == hash("space") and action.pressed then
		spawn_ball(self)
	end
end

local function get_random_basket(baskets)
	local total_probability = 0
	for _, basket in pairs(baskets) do
		total_probability = total_probability + basket.probability
	end

	local random_value = math.random() * total_probability
	local cumulative_probability = 0

	for _, basket in pairs(baskets) do
		cumulative_probability = cumulative_probability + basket.probability
		if random_value <= cumulative_probability then
			return basket.records
		end
	end
end

local function spawn_ball(self)
	if balls > 0 and #ball_pool > 0 then
		balls = balls - 1
		save_data()
		local file_path_records = get_random_basket(self.baskets)
		local ball = table.remove(ball_pool)  -- Берем шарик из пула
		msg.post(ball, "enable")  -- Включаем объект
		msg.post(ball, "start_animation", { records = file_path_records })
		msg.post("/background#mainScreen", "update_count_balls", { text = balls.."/"..MAX_BALLS })
		table.insert(active_balls, ball)  -- Добавляем в активные шарики
	else
		print("No more balls to spawn!")
	end
end

local function spawn_next_ball(self)
	if #spawn_queue > 0 then
		spawn_ball(self)
		table.remove(spawn_queue, 1)
		if #spawn_queue > 0 then
			timer.delay(SPAWN_INTERVAL, false, function() spawn_next_ball(self) end)
		else
			is_spawning = false -- сбрасываем флаг после завершения спауна
		end
	end
end

local function spawn_balls(self, count)
	if is_spawning then
		print("Already spawning balls!")
		return
	end

	if balls < count then
		print("Not enough balls to spawn!")
		return
	end

	is_spawning = true
	for i = 1, count do
		table.insert(spawn_queue, true)
	end
	if #spawn_queue > 0 then
		spawn_next_ball(self)
	end
end

local function add_balls(count)
	balls = math.min(balls + count, MAX_BALLS)
	save_data()
	msg.post("/background#mainScreen", "update_count_balls", { text = balls.."/"..MAX_BALLS })
end

function update(self, dt)
	-- Восстанавливаем шарики
	if balls < MAX_BALLS then
		self.restore_timer = self.restore_timer - dt
		if self.restore_timer <= 0 then
			add_balls(RESTORE_AMOUNT)
			self.restore_timer = RESTORE_INTERVAL
		end
	else
		self.restore_timer = RESTORE_INTERVAL
	end

	-- Обновляем таймер на GUI
	local remaining_time = math.floor(self.restore_timer)
	if balls < MAX_BALLS then
		local minutes = math.floor(remaining_time / 60)
		local seconds = remaining_time % 60
		msg.post("/background#mainScreen", "update_timer", { text = string.format("+5 balls in %02d:%02d", minutes, seconds) })
	else
		msg.post("/background#mainScreen", "update_timer", { text = "You got all the balls" })
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("spawn_ball") then
		spawn_ball(self)
	elseif message_id == hash("spawn_balls") then
		spawn_balls(self, message.count)
	elseif message_id == hash("add_balls") then
		add_balls(message.count)
	elseif message_id == hash("baskets_loaded") then
		local received_baskets = message.baskets
		for id_str, basket in pairs(received_baskets) do
			self.baskets[id_str] = basket
		end
	elseif message_id == hash("release_ball") then
		local ball = message.ball
		msg.post(ball, "reset_and_disable")  -- Сбрасываем и отключаем объект
		table.insert(ball_pool, ball)  -- Возвращаем шарик в пул
		for i, active_ball in ipairs(active_balls) do
			if active_ball == ball then
				table.remove(active_balls, i)
				break
			end
		end
	end
end
